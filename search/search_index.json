{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Chassis 2024","text":""},{"location":"#what-is-chassis-2024","title":"What is Chassis 2024?","text":"<p>Chassis 2024 is a general-purpose Python framework, designed to orchestrate the loading and termination process of reusable infrastructure. It automates the nitty-gritty of setup and teardown, allowing programmers to quickly focus on the more exciting parts of their application. With Chassis 2024, you\u2019re equipped to rapidly establish a robust and dependable infrastructure for your program, ensuring it's not just functional, but also of high quality and tailored to your needs.</p>"},{"location":"#installation","title":"Installation","text":"<p>If you've already got Python installed on your system, setting up Chassis2024 is straightforward. Just run the following command:</p> <pre><code>pip install chassis2024\n</code></pre> <p>This command will download Chassis2024 along with any dependencies it requires and install them for you.</p>"},{"location":"archive/","title":"Archive","text":"<p>Announcements:</p> <ul> <li>r/madeinpython -- Infrastructure Loading System: Chassis</li> </ul>"},{"location":"concepts/","title":"Chassis 2024: Introduction to Core Concepts and Terminology","text":""},{"location":"concepts/#welcome-to-chassis-2024","title":"Welcome to Chassis 2024","text":"<p>Simplifying Software Infrastructure Management</p> <p>Welcome to Chassis 2024, a tool I designed to transform the experience of software development by simplifying the reuse of infrastructure components. With Chassis 2024, the aim is to eliminate the repetitive and tedious aspects of writing boilerplate code, allowing you to focus on the more creative and unique parts of your projects. By facilitating the easy instantiation and configuration of reusable components, and ensuring their orderly execution, Chassis 2024 makes software development more efficient and enjoyable.</p> <p>In this guide, I'll introduce you to the core concepts and unique terminology of Chassis 2024, providing you with the foundational knowledge to effectively utilize this tool in your projects.</p>"},{"location":"concepts/#who-should-read-this-guide","title":"Who Should Read This Guide","text":"<p>Tailored for the Experienced Developer</p> <p>This guide is intended for intermediate to advanced programmers who already have a solid foundation in software development and are looking to explore innovative approaches in infrastructure management. It's particularly suited for those familiar with Python, including an understanding of Python modules, packages, and the standard library.</p> <p>Prerequisite Knowledge:</p> <ul> <li>Proficiency in programming, particularly in Python.</li> <li>Familiarity with software architecture concepts and the challenges of software infrastructure management.</li> </ul> <p>This guide is not designed for absolute beginners in programming. The concepts and implementations discussed require a certain level of technical proficiency and an understanding of advanced programming paradigms.</p> <p>As you delve into this guide, Chassis 2024 will provide insights into managing reusable software components efficiently.</p>"},{"location":"concepts/#key-terminology-in-chassis-2024","title":"Key Terminology in Chassis 2024","text":"<p>Understanding the specific terminology of Chassis 2024 is crucial for grasping its unique approach to software infrastructure. Here are key terms explained in the context of Chassis 2024:</p>"},{"location":"concepts/#infrastructure","title":"Infrastructure","text":"<p>In Chassis 2024, \"infrastructure\" refers to modular, reusable components integral to your software's structure and execution flow. Examples of infrastructure components include:</p> <ul> <li>Configuration Management: Modules for reading and applying configurations from external files.</li> <li>Command-Line Argument Processing: A component for interpreting command-line arguments to configure the software.</li> <li>Lock File Management: A mechanism to check for lock files, preventing simultaneous multiple instances of the application.</li> <li>Persistent Data Management: A component focused on managing persistent data, including reading persistence files at application start-up and writing them during program termination.</li> <li>Network Operations: Components for establishing and managing network operations, like TCP servers or database connections.</li> <li>Establishing Logging: Components for setting up loggers, or other kinds of reporting features.</li> <li>User Interface Management: A component for setting up and managing user interfaces, such as initializing a graphical framework.</li> </ul> <p>Chassis 2024 simplifies the integration and configuration of infrastructure components, orchestrating them into a single, properly ordered execution.</p>"},{"location":"concepts/#infrastructure-vs-component","title":"\"Infrastructure\" vs \"Component\"","text":"<p>The term \"component\" is commonly used in software architecture, but Chassis 2024 uses \"infrastructure\" to avoid confusion with systems like CORBA, COM, DCOM, Active X, microservices, or Python-specific systems like Pluggy or the Zope Component Architecture. While sharing some features with these architectures, Chassis 2024's focus is distinct.</p> <p>\"Infrastructure\" in Chassis 2024 highlights the tool's unique approach to combining software components. Chassis 2024 focuses on the orchestration of loading sequences and teardown processes, ensuring that tasks are executed in the correct order and manner. This emphasis on execution order and seamless integration of elements sets Chassis 2024 apart from other architectures, which often prioritize inter-component communication.</p>"},{"location":"concepts/#execution-nodes","title":"Execution Nodes","text":"<p>In Chassis 2024, \"execution nodes\" refer to distinct stages or points within the software's execution process. These nodes represent specific states or activities in the lifecycle of an application, such as initialization, operation, and termination. Chassis 2024 allows infrastructure to define execution nodes, and to precisely control and manage the order in which the execution nodes are executed. This concept is crucial for ensuring that each element of the infrastructure performs its designated function at the appropriate time in the overall execution flow.</p>"},{"location":"concepts/#execution-graph","title":"Execution Graph","text":"<p>The \"execution graph\" in Chassis 2024 is a representation of the relationships and dependencies between different execution nodes. It maps out how these nodes are interconnected, forming a structured pathway that guides the execution order of the software components. The graph is predominantly shaped by the infrastructure components within the system, with some predeclared nodes provided by Chassis 2024. Kahn's algorithm is applied to this graph to dynamically determine the optimal sequence for executing different parts of the application, ensuring efficiency and preventing conflicts or dependency issues.</p>"},{"location":"concepts/#interface","title":"Interface","text":"<p>In Chassis 2024, an \"interface\" is a conceptual contract that defines the expected functionalities and attributes of modules within the system. Identified by unique string names, interfaces serve as a simple yet powerful way for modules to communicate their capabilities and roles. This system allows each interface to be implemented by only one module, promoting clear and direct interactions between different parts of the software. This streamlined approach to interfaces reflects Chassis 2024's emphasis on simplicity, flexibility, and clear, unambiguous connections within the software's architecture.</p>"},{"location":"concepts/#core-concepts","title":"Core Concepts","text":""},{"location":"concepts/#architecture-overview","title":"Architecture Overview","text":"<p>Chassis 2024 is designed with a modular architecture, focusing on clear definitions and interactions among various infrastructure components within a software system. Here's an overview of how this architecture is organized and functions:</p> <ul> <li> <p>Module Infrastructure Declaration: Modules in Chassis 2024 declare their role as part of the system's infrastructure by defining a CHASSIS2024_SPEC variable. This variable is a key element, tagging the module as infrastructure and providing essential information to the Chassis 2024 system. It can specify a range of details such as a list of implemented interfaces, extensions to the execution graph, or execution nodes managed by the module.</p> </li> <li> <p>Importing Infrastructure Modules: Modules explicitly import the infrastructure components they require. Each of these imported modules has its CHASSIS2024_SPEC defined, allowing the Chassis 2024 system to recognize and integrate them as part of the overall infrastructure. When chassis2024.run() is executed, the system dynamically scans sys.modules to identify all modules that define CHASSIS2024_SPEC, incorporating them into the execution process.</p> </li> <li> <p>Program Initialization: The initiation of Chassis 2024 typically occurs in a central module, often the one that starts the program (like package.main.py or a standalone module). This module will include a conditional statement if name == \"main\" followed by the chassis2024.run() call. It is crucial that all necessary infrastructure modules are imported before this point, ensuring they are recognized and activated by the system upon startup.</p> </li> <li> <p>Execution Specification: During the execution of chassis2024.run(), the user has the option to provide an \"execution spec\" as the first argument. This specification acts as a configuration guide for the execution process, offering a way for modules to access shared configuration data through the chassis2024.chassis module. This feature adds an extra layer of flexibility, allowing for customized control over the execution flow based on the provided specifications.</p> </li> </ul> <p>Don't worry if this all seems a bit complex at first glance. In the upcoming tutorials, we'll be walking through each of these concepts in detail, with friendly introductions and practical examples. The aim is to make sure you're comfortable and fully understand how to leverage Chassis 2024's capabilities in your projects.</p>"},{"location":"concepts/#design-philosophy","title":"Design Philosophy","text":"<p>The design philosophy of Chassis 2024 is built around several key principles:</p> <ul> <li> <p>Rapid Prototyping: Chassis 2024 is engineered to enable rapid prototyping.  It achieves this by making it easy to incorporate and configure infrastructure, and by taking care of all execution timing issues.</p> </li> <li> <p>Correctness Without Sacrificing Developer Time: Chassis 2024 is committed to ensuring correctness in software execution without sacrificing the developer's time. Infrastructure components are designed to handle intricate details, such as locking mechanisms and PID file checks, ensuring that essential yet often overlooked aspects of software infrastructure are managed correctly. This approach allows developers to focus on writing engaging, innovative code, free from the burden of repetitive tasks that require meticulous attention to detail.</p> </li> <li> <p>Flexibility and Modularity: Embracing a modular approach, Chassis 2024 provides the flexibility to combine different (and even novel) infrastructure components as needed. This modularity means that the system can be adapted to a variety of applications, ensuring that each project's unique requirements are met efficiently.</p> </li> <li> <p>Developer-Centric Design: The system is created with the developer's workflow as a priority, focusing on features that enhance productivity and creativity. Chassis 2024 aims to make the development process not just more efficient but also more enjoyable.</p> </li> <li> <p>Convention Over Configuration: While offering customization, Chassis 2024 leans towards convention over configuration, providing sensible defaults that cover common scenarios. This approach eases the learning curve and reduces setup time, allowing developers to dive into the creative aspects of programming more quickly.</p> </li> <li> <p>Emphasis on Execution Order: Chassis 2024 places a strong emphasis on the execution order of software components. This ensures seamless operation and interaction among different parts of the system, addressing common challenges in complex software infrastructures.</p> </li> <li> <p>Community and Collaboration: It is my hope that other developers will see promise in this approach, and that a supportive community will develop around the Chassis system.  Collaboration and user feedback are crucial to evolve Chassis 2024 to meet the dynamic needs of its users.</p> </li> </ul> <p>This philosophy guides every facet of Chassis 2024, from its features to its user experience, ensuring that it remains a powerful yet user-friendly tool for efficient and correct software infrastructure management.</p>"},{"location":"concepts/#execution-flow","title":"Execution Flow","text":""},{"location":"concepts/#how-to-use-this-guide","title":"How to Use This Guide","text":""},{"location":"concepts/#as-a-primer","title":"As a Primer","text":""},{"location":"concepts/#as-a-reference","title":"As a Reference","text":""},{"location":"concepts/#next-steps","title":"Next Steps","text":""},{"location":"concepts/#moving-to-practice","title":"Moving to Practice","text":""},{"location":"concepts/#further-reading","title":"Further Reading","text":""},{"location":"ex_10_helloworld/","title":"Ex #1: Hello, world!","text":""},{"location":"ex_10_helloworld/#introduction-to-hello-world-with-chassis-2024","title":"Introduction to \"Hello, World!\" with Chassis 2024","text":"<p>\u3069\u3046\u305e\u3001\u304a\u5165\u308a\u304f\u3060\u3055\u3044\uff01  (Please come in!)</p> <p>Welcome to the first steps in learning Chassis 2024! In this tutorial, we'll explore the basics of creating a foundational \"Hello, World!\" program using Chassis 2024. This journey will be your gateway to understanding how Chassis 2024 streamlines software development by seamlessly integrating various infrastructure components.</p> <p>What We'll Cover:</p> <ul> <li>Getting Started: We'll begin by setting up a basic Chassis 2024 environment, ensuring you have everything you need to start coding.</li> <li>Code Anatomy: Dive deep into the structure of a Chassis 2024 program. We'll dissect our 'Hello, World!' example, examining each part's role and how they work together.</li> <li>Key Concepts: Understand the crucial elements of Chassis 2024, including CHASSIS2024_SPEC and interface implementations. This will build your foundation for more advanced topics in future tutorials.</li> </ul> <p>Through thought experiments at the end, we'll explore different scenarios, enhancing your understanding of how Chassis 2024 handles various situations.</p> <p>By The End of This Tutorial:</p> <p>You'll have a comprehensive understanding of setting up a basic Chassis 2024 project and the importance of its components, laying a solid foundation for tackling more complex scenarios with Chassis 2024.</p> <p>\u3044\u304f\u305c!</p>"},{"location":"ex_10_helloworld/#understanding-the-basics-via-hello-world","title":"Understanding the Basics via Hello, World!","text":"<p>Here's a \"Hello, world!\" program.</p> <p>Copy it into a file called <code>helloworld.py</code>, and run it.</p> <p>(If you don't have chassis2024 installed, run <code>pip install chassis2024</code> to install it, first.)</p> <pre><code># helloworld.py\n\nimport sys\n\nimport chassis2024\nimport chassis2024.basicrun\n\n\nCHASSIS2024_SPEC = {\n    \"INTERFACES\": {\"RUN\": sys.modules[__name__]}\n}\n\n\n# interface: RUN\ndef run():\n    print(\"Hello, world!\")\n\n\nif __name__ == \"__main__\":\n    chassis2024.run()\n</code></pre>"},{"location":"ex_10_helloworld/#things-to-notice","title":"Things to Notice","text":"<p>So, what are we looking at here?</p> <ul> <li>imports -- There are two imports:</li> <li><code>import chassis2024</code></li> <li><code>import chassis2024.basicrun</code></li> <li><code>CHASSIS2024_SPEC</code> -- a dictionary, with one key:</li> <li><code>\"INTERFACES\"</code> -- a declaration of an interface binding, specifically, ...<ul> <li><code>\"RUN\"</code> -- the name of an interface, implemented by...</li> <li><code>sys.modules[__name__]</code> -- in Python, this means: \"this module\"</li> </ul> </li> </ul> <p>We'll talk about these piece by piece.</p> <p></p>"},{"location":"ex_10_helloworld/#import-chassis2024","title":"import chassis2024","text":"<p>The first import is straightforward: <code>import chassis2024</code></p> <p>That loads the chassis2024 system into memory (<code>sys.modules</code> specifically).</p>"},{"location":"ex_10_helloworld/#import-chassis2024basicrun","title":"import chassis2024.basicrun","text":"<p>The second import is a little more mysterious: <code>import chassis2024.basicrun</code></p> <p>What is <code>chassis2024.basicrun</code>?  It's one of the built-in infrastructure package that ships with chassis2024.</p> <p>Chassis 2024 programs are assembled from infrastructure.  Infrastructure basically means: a part of the system that has steps that must be followed, and that must be followed at particular times.</p> <p>What <code>chassis2024.basicrun</code> does, is that after everything else is set up, it will call a <code>run()</code> function.</p> <p>Q: \"Which run() function will it run?\"</p> <p>A: We'll get to that.</p> <p>Q: \"How does it time things?\"</p> <p>A: We'll get to that -- much later.  It's a critical question, and central to what chassis2024 is, and how it works, but I can't answer that right now.  Just trust that there are ways to control timings.  But it's a good question to bear in mind.</p> <p>The key things to understand right now, are that:</p> <ul> <li><code>import chassis2024</code> -- This line imports the Chassis 2024 system as a whole, and...</li> <li><code>import chassis2024.basicrun</code> -- ...this line includes the \"basic run\" infrastructure into our program's execution.</li> </ul> <p>If you've got just that, you're good for the next piece.</p>"},{"location":"ex_10_helloworld/#understanding-chassis2024_spec","title":"Understanding CHASSIS2024_SPEC","text":"<p>This identifier plays a pivotal role in Chassis 2024.  When you define <code>CHASSIS2024_SPEC</code> in your module, you're essentially tagging it as a piece of \"infrastructure.\"  This tag is a univresal feature across all infrastructure components in Chassis 2024, signaling to the system that your module plays a crucial role in the overall architecture.</p> <p>Here's how it works in the helloworld.py example:</p> <pre><code>CHASSIS2024_SPEC = {\n    \"INTERFACES\": {\"RUN\": sys.modules[__name__]}\n}\n</code></pre> <p>The Chassis 2024 system sees a definition of CHASSIS2024_SPEC, and recognizes, \"This module is infrastructure.\"</p> <p>All infrastructure packages and modules define <code>CHASSIS2024_SPEC</code>.</p> <p>Yes: <code>chassis2024.basicrun</code> has a <code>CHASSIS2024_SPEC</code> block at the top of it's implementation, because it is an infrastructure package, and all infrastructure packages define <code>CHASSIS2024_SPEC</code>.</p> <p>The Chassis 2024 system doesn't stop with recognizing \"this is infrastructure,\" though -- it also uses the data that <code>CHASSIS2024_SPEC</code> is assigned to.</p>"},{"location":"ex_10_helloworld/#interfaces-and-the-run-interface","title":"\"INTERFACES\" and the \"RUN\" interface","text":"<p>Look again at the <code>CHASSIS2024_SPEC</code> definition:</p> <pre><code>CHASSIS2024_SPEC = {\n    \"INTERFACES\": {\"RUN\": sys.modules[__name__]}\n}\n</code></pre> <p>What does <code>chassis2024</code> make of <code>\"INTERFACES\"</code>?  And what is the <code>\"RUN\"</code> interface all about?</p> <p>This is a declaration to <code>chassis2024</code> binding \"interfaces.\"  In particular, it's binding the <code>\"RUN\"</code> interface to the immediate module (<code>helloworld.py</code> -- referring to itself via <code>sys.modules[__name__]</code>).</p> <p>Interfaces are how infrastructure finds infrastructure. <code>helloworld.py</code>, in writing this, is declaring that it is implementing the <code>\"RUN\"</code> interface.  Whenever someone asks <code>chassis2024</code> for the <code>\"RUN\"</code> interface implementor, it'll return the <code>helloworld</code> module back to the caller.</p> <p>Each interface can only be implemented by a single module.  Interfaces have a \"zero or one\" relationship with the modules that implement them:  Either it's implemented, or it's not, and if it's implemented, it's implemented by only one single module.</p> <p>If multiple modules attempt to implement the same interface, an exception is raised (<code>MultipleDefinitionsOfInterface</code>).</p> <p>What an interface is good for is not rigorously defined by Chassis 2024.  There are no schemas, no interface classes and no interface definition objects,  there are no systems for discovery, or for publishing.  Rather, an interface is simply defined by a string identifier (like \"RUN\"), and by the expectations of use between the infrastructure that uses an interface, and infrastructure that meets an interface, held in the mind of the programmer(s).</p> <p>When <code>chassis2024.basicrun</code> gets a hold of the thing at the other end of the <code>\"RUN\"</code> interface (<code>helloworld.py</code>, in this case,) it simply calls the <code>run()</code> function on it.  If it's not implemented, some sort of exception will be raised -- whatever exception is raised when you make a function call that isn't defined.  Your code will be in error.</p> <p><code>helloworld.py</code> does not want to be in error, hence it implements the <code>run()</code> function:</p> <pre><code># interface: RUN\ndef run():\n    print(\"Hello, world!\")\n</code></pre>"},{"location":"ex_10_helloworld/#recap","title":"Recap","text":"<p>OK, so -- you should be able to understand the program now:</p> <pre><code>import sys\n\nimport chassis2024\nimport chassis2024.basicrun\n\n\nCHASSIS2024_SPEC = {\n    \"INTERFACES\": {\"RUN\": sys.modules[__name__]}\n}\n\n\n# interface: RUN\ndef run():\n    print(\"Hello, world!\")\n\n\nif __name__ == \"__main__\":\n    chassis2024.run()\n</code></pre> <p></p> <ul> <li>First, it imports the <code>chassis2024</code> system itself.</li> <li>Then, it imports the <code>chassis2024.basicrun</code> infrastructure.</li> <li>Then it declares itself to be infrastructure (by defining CHASSIS2024_SPEC).</li> <li>In that declaration, it also declares that it implements the RUN interface.</li> <li>Notably, it is the sole implementer of the RUN interface.  All interfaces are only ever implemented once and there are no exceptions to this rule.</li> <li>Then it defines the <code>run()</code> function, which by the way is the expectation of the \"RUN\" interface, by the <code>chassis2024.basicrun</code> infrastructure.</li> <li>And then, finally it runs <code>chassis2024</code>.</li> <li>The first thing chassis2024 will do, is examine all imported modules, and identify infrastructure.<ul> <li>It will find <code>helloworld.py</code>.</li> <li>It will note down that <code>helloworld.py</code> implements the <code>\"RUN\"</code> interface.</li> <li>It will find <code>chassis2024.basicrun</code>.</li> </ul> </li> <li>It will then assemble the execution graph.  (You can skip ahead if you want to read more about the execution graph right away.)</li> <li>It will then execute all of the execution nodes.</li> <li>When the system is up (in the \"UP\" execution node,) <code>chassis2024.basicrun</code> will call the <code>\"RUN\"</code> interface's <code>run()</code> method ...</li> <li>...which means that <code>helloworld.run()</code> is what will be called.</li> </ul>"},{"location":"ex_10_helloworld/#thought-experiments","title":"Thought Experiments","text":""},{"location":"ex_10_helloworld/#thought-experiment-1-implementing-run-in-a-different-module","title":"Thought Experiment #1: Implementing RUN in a different module.","text":"<p>Q: \"What if I imported another module, that had a CHASSIS2024_SPEC in it, and that module implemented the \"RUN\" interface instead?\"</p> <p>A: Then the <code>MultipleDefinitionsOfInterface</code> exception would be raised.</p> <p>Q: \"Oh, okay, -- but, -- what if I had taken out the CHASSIS2024_SPEC declaration from <code>helloworld.py</code> itself?\"</p> <p>A: That'd be okay then.  It'd call the <code>run()</code> function on the other module, then.</p>"},{"location":"ex_10_helloworld/#thought-experiment-2-what-if-nobody-implements-run","title":"Thought Experiment #2: What if nobody implements RUN?","text":"<p>Q: \"What if nobody implemented RUN?\"</p> <p>A: When it comes time to get the RUN interface, which is required by basicspec, then it'll raise an <code>InterfaceUndefined</code> exception.</p> <p>Here's the relevant code from <code>chassis2024/basicrun/__init__.py</code>:</p> <pre><code>def perform_execution_graph_node(n):\n    if n == UP:\n        chassis2024.interface(RUN, required=True).run()\n</code></pre> <p>...you can see it has \"required=True\" set, in it's call to resolve the interface, and then in <code>chassis2024/__init__.py</code>,  ...</p> <pre><code>def interface(interface_name, required=False):\n    \"\"\"Access the object registered for a given interface.\n\n    If it doesn't exist, and it's not required, return None.\n\n    If it doesn't exist, and it's required, raises InterfaceUndefined.\n    \"\"\"\n    found = chassis.interfaces.get(interface_name)\n    if required and not found:\n        raise InterfaceUndefined(interface_name)\n    return found\n</code></pre> <p>See?  If <code>required</code> is <code>true</code>, (and it is in the call from the <code>basicrun</code> source code,) if the interface name can't be found, it raises <code>InterfaceUndefined(\"RUN\")</code>, here.</p>"},{"location":"ex_10_helloworld/#t-junction","title":"T-Junction","text":"<p>You arrive at a T-Junction.</p> <p>You can go left, to the Chassis 2024 title page.</p> <p>You can go right, to the next example tutorial...</p>"},{"location":"ex_20_echo/","title":"Ex #2: Echo","text":""},{"location":"ex_20_echo/#an-example-echo-echo-echo-eo-e","title":"An Example: ECHO! Echo! echo! e..o!  e...!  ...!","text":"<p>Here's an \"Echo\" program.</p> <p>We're building on top of knowledge from the last program, <code>helloworld.py</code>.</p> <p>(I strongly urge you to read that one, before attempting this one.).</p> <p><code>echo.py</code>:</p> <pre><code>import sys\n\nimport chassis2024\nimport chassis2024.basicrun\nimport chassis2024.argparse\nfrom chassis2024.words import *\nfrom chassis2024.argparse.words import *\n\n\nthis_module = sys.modules[__name__]\n\n\nCHASSIS2024_SPEC = {\n    INTERFACES: {RUN: this_module,\n                 ARGPARSE_CONFIGURE: this_module}\n}\n\n\n# interface: ARGPARSE_CONFIGURE\ndef argparse_configure(parser):\n    parser.add_argument(\"-e\", \"--echo\",\n                        help=\"input string to echo\",\n                        default=\"use -e to specify string to echo\")\n\n# interface: RUN\ndef run():\n    argparser = chassis2024.interface(ARGPARSE, required=True)\n    print(argparser.args.echo)\n\n\nif __name__ == \"__main__\":\n    chassis2024.run()\n</code></pre>"},{"location":"ex_20_echo/#noticing","title":"Noticing...","text":"<p>OK, things to notice:</p> <ul> <li><code>import chassis2024.argparse</code> -- More infrastructure: the <code>chassis2024.argparse</code> infrastructure.</li> <li><code>from &lt;...&gt;.words import *</code> -- \"Words.\"  Lots of words.  We'll talk about it.</li> <li>interface <code>\"ARGPARSE_CONFIGURE\"</code></li> <li>interface <code>\"RUN\"</code> -- exactly as before</li> <li><code>argparser = chassis2024.interface(ARGPARSE, required=True)</code> -- this is interface access, and we'll talk about it</li> <li><code>argparser.args.echo</code> -- accessing the \"echo\" argument from the ArgumentParser.  Which we'll talk about.</li> <li><code>chassis2024.run()</code> invocation -- just like last time (and working exactly the same) -- we will not talk about this again.</li> </ul>"},{"location":"ex_20_echo/#chassis2024argparse-infrastructure","title":"\"chassis2024.argparse\" infrastructure","text":"<p>The most important piece here, is the incorporation of the <code>chassis2024.argparse</code> infrastructure.</p> <p>What it does is -- after the modules have been cleared and reset (which you can learn more about in the section on the execution graph, -- you might want to just take a peek at, real quick,) the argument parser is assembled, and then populated.  By \"populated,\" I mean: arguments are defined on the argument parser.</p> <p>It's populated by calling the <code>ARGPARSE_CONFIGURE</code> interface implementation (which: in this case, is defined to be in <code>echo.py</code>):</p> <pre><code>CHASSIS2024_SPEC = {\n    INTERFACES: {RUN: this_module,\n                 ARGPARSE_CONFIGURE: this_module}\n}\n</code></pre> <p>Now, the argument parser, we must be clear, is the Python \"batteries included\" argparse.ArgumentParser.  Detailing it and how it works, is beyond the scope of this Chassis 2024 documentation.</p> <p>If you understand argparse.ArgumentParser, though, then this will be clear:</p> <pre><code># interface: ARGPARSE_CONFIGURE\ndef argparse_configure(parser):\n    parser.add_argument(\"-e\", \"--echo\",\n                        help=\"input string to echo\",\n                        default=\"use -e to specify string to echo\")\n</code></pre> <p>You might be wondering, though:  \"How do you get at the arguments that were parsed out?\"</p> <p>That's the very next subject.</p>"},{"location":"ex_20_echo/#accessing-the-argparse-interface","title":"Accessing the ARGPARSE Interface","text":"<p>It's in this code, here:</p> <pre><code>#interface: RUN\ndef run():\n    argparser = chassis2024.interface(ARGPARSE, required=True)\n    print(argparser.args.echo)\n</code></pre> <p>The first thing that the <code>echo.run()</code> function does, is load the <code>\"ARGPARSE\"</code> interface.</p> <p>The <code>chassis2024.argparse</code> package implements it.  The implementation of \"ARGPARSE\" essentially means that it has two identifiers defined on it:  <code>.parser</code>, and <code>.args</code>.  After the parse happens (and we'll talk about the execution nodes and timing,) then <code>.args</code> has the arguments loaded into it, by the time <code>run()</code> is called.</p> <p>Since the <code>RUN</code> interface is called by <code>chassis2024.basicrun</code> as the last thing in the execution graph, it's guaranteed to be filled by this time.</p>"},{"location":"ex_20_echo/#a-quick-question-about-chassis2024interface-calls","title":"...a quick question about chassis2024.interface calls...","text":"<p>Q: \"I see that it says, <code>required=True</code>.  What if <code>\"ARGPARSE\"</code> had not been defined?\"</p> <p>A: Well, the interface is bound by the <code>chassis2024.argparse</code> package.  But let's say it hadn't been.  Then when that call to <code>chassis2024.interface(ARGPARSE, required=True)</code> is called, it'll raise <code>InterfaceUndefined</code>.</p> <p>Q: \"And what if required was <code>required=False</code>?\"</p> <p>A: If it wasn't implemented, it'd just return None.</p> <p>But I want to be clear:  if you <code>import chassis2024.argparse</code>, the <code>ARGPARSE</code> interface will absolutely definitely be defined -- it'll be defined to that module itself.</p> <p>Q: \"Could you just directly read chassis2024.argparse.args?\"</p> <p>A: Yes, you can.  But one of the goals of the system is to make infrastructure swappable.  You could write a different argparse module, for your special needs.  Perhaps the ordering in your particular execution is really weird, and breaks some of the assumptions that the other infrastructure makes.  You had to make something special.  As long as you implement <code>.parser</code> and <code>.args</code> just the same, and declare your new module to meet the <code>ARGPARSE</code> interface, then the code should still work.  You just need to change the <code>import chassis2024.argparse</code> to <code>import &lt;your-code&gt;.argparse</code>, or whatever, and it'll work.</p> <p>Q: \"That seems unlikely.  Are you sure you aren't just being pedantic?\"</p> <p>A: Hm, ...  Maybe I am.  But this is how it makes sense to me to think about it.  Do what you like.</p>"},{"location":"ex_20_echo/#wait-a-second-what-about-the-words","title":"Wait a second!  What about the \"words\"?!","text":"<p>OK.</p> <p>This is really basic.</p> <pre><code>from chassis2024.words import *\nfrom chassis2024.argparse.words import *\n</code></pre> <p>I'll show you what the text of <code>chassis2024.words</code> looks like, somewhat abbreviated:</p> <pre><code># Copyright 2024 Lion Kimbro\n# SPDX-License-Identifier: BSD-3-Clause\n\nCHASSIS2024_SPEC = \"CHASSIS2024_SPEC\"\n...\nINTERFACES = \"INTERFACES\"\n...\n# common interfaces\nRUN = \"RUN\"  # basicrun: .run()\nARGPARSE = \"ARGPARSE\"  # argparse: .parser, .args\nPERSISTENCE_DATA = \"PERSISTENCE_DATA\"  # basicjsonpersistence: .data, .save()\n...\n# MAJOR STAGES\nCLEAR = \"CLEAR\"\nRESET = \"RESET\"\nARGPARSE = \"ARGPARSE\"\nCONNECT = \"CONNECT\"\nACTIVATE = \"ACTIVATE\"\nUP = \"UP\"\n...\n</code></pre> <p>See?  That's all it is.</p> <p>These variables (RUN, ARGPARSE, PERSISTENCE_DATA) are what I call \"words.\"  (Or to use more technical jargon, these are \"symbols\", their value is their own name, and the id is fixed in the string interning table.)</p> <p>I use \"words\" for three reasons:</p> <ul> <li>To save two whole characters in dictionary indexing -- it's <code>RUN</code>, rather than <code>\"RUN\"</code>.  I like it much better as <code>RUN</code>.</li> <li>To syntax highlight the common keys as identifiers, rather than as strings, which creates a different impression in my mind.</li> <li>The real reason:  To detect errors earlier.  If I type \"INTERFCES\", rather than \"INTERFACES\", then there will just be a silent but horrifying omission -- \"Hm, looks like the user didn't want to define any INTERFACES here...  Things won't work, and I'll have to trouble-shoot to find out why.  But if I use the word INTERFCES. rather than the word INTERFACES, then at import time, Python will say, \"Hey, you're talking about an identifier INTERFCES that you haven't defined yet.\"  So it makes me feel immensely more secure to just define words for my dictionary keys.</li> </ul> <p>I have met people who don't like any of this.  They say, \"It's Python, it's a dictionary, it's supposed to have string keys...\"  \"You should use a class and an object and attributes, if you want to do this...\"  But then, even if I do, I still have the same problem -- because Python will let you assign to foo.interfces, no problem, ...  ANYWAYS.  If you don't like it, don't import words, and just ignore them.  You can program using just strings for keys if you like, everything will work fine.</p>"},{"location":"ex_20_echo/#recap","title":"Recap","text":"<p>So, as before, a revisiting of the <code>echo.py</code> example as a totality:</p> <pre><code>import sys\n\nimport chassis2024\nimport chassis2024.basicrun\nimport chassis2024.argparse\nfrom chassis2024.words import *\nfrom chassis2024.argparse.words import *\n\n\nthis_module = sys.modules[__name__]\n\n\nCHASSIS2024_SPEC = {\n    INTERFACES: {RUN: this_module,\n                 ARGPARSE_CONFIGURE: this_module}\n}\n\n\n# interface: ARGPARSE_CONFIGURE\ndef argparse_configure(parser):\n    parser.add_argument(\"-e\", \"--echo\",\n                        help=\"input string to echo\",\n                        default=\"use -e to specify string to echo\")\n\n# interface: RUN\ndef run():\n    argparser = chassis2024.interface(ARGPARSE, required=True)\n    print(argparser.args.echo)\n\n\nif __name__ == \"__main__\":\n    chassis2024.run()\n</code></pre> <ul> <li>\u307e\u305a\u3001(\"first off,\") we import the <code>chassis2024</code> system itself.</li> <li>Then the infrastructure used: <code>chassis2024.basicrun</code>, and <code>chassis2024.argparse</code>.</li> <li>Then words for the modules, since there is specialized language here.</li> <li>Then we define the <code>CHASSIS2024_SPEC</code>, and in particular, insisting that RUN and ARGPARSE_CONFIGURE interfaces are implemented by <code>echo.py</code>.</li> <li>And again, I re-emphasize that interfaces can only be implemented by a single module.  This isn't pluggy.  This isn't Zope components.  This isn't any kind of bus or component or plug-in system.  It's just a system for sequencing critical infrastructure for setup and teardown.</li> <li>Then the ARGPARSE_CONFIGURE interface is implemented.  The parser is configured in this way.</li> <li>Then the RUN interface is implemented.</li> <li>The first thing it does, is located the argparser.</li> <li>Then it drills down for the <code>args</code>, and pulls out the <code>echo</code> argument.</li> <li>Then it prints it.</li> <li>And then the <code>chassis2024</code> system is run.</li> </ul>"},{"location":"ex_20_echo/#thought-experiments","title":"Thought Experiments","text":"<p>Feel free to skip, but this can give you some insight into the inner logic behind chassis2024.</p>"},{"location":"ex_20_echo/#thought-experiment-1-other-infrastructure-registering-arguments","title":"Thought Experiment #1: Other Infrastructure Registering Arguments","text":"<p>Q: \"Hey, can other pieces of infrastructure register themselves on the argument parser?\"</p> <p>A: ... Yes...</p> <p>Q: \"For example, if I made a piece of infrastructure that pulled some data from a remote host and port, it could collect the --host and --port via <code>chassis2024.argparse</code>, right?\"</p> <p>A: ... Yes...</p> <p>Q: \"Why so cagey?  Isn't this exactly what the system was made for?\"</p> <p>A: ...</p> <p>A: Okay, so, YES, and NO.</p> <p>Q: ?</p> <p>A: What I mean is:  YES, you absolutely can do that.  And the system is set up to give you that freedom, to do it.  You can define an execution node, after the argument parser is defined, and before it performs it's parse, and you can automatically register arguments on it, by reaching out to it by interface, but, ...</p> <p>Q: \"-- but what?\"</p> <p>A: It was important to me to make sure that the programmer has ultimate control over how the ArgumentParser presents to the user.  I wanted programmers to be able to use pre-existing infrastructure, and yet not have to compromise on the presentation to the user.  I mean, the user is the programmer's user, right?  Not necessarily the infrastructure programmer's user.  And the ArgumentParser -- because it can display --help, and because the options themselves are defined on it -- I wanted to make sure that that was all in the control of the programmer.</p> <p>Q: \"Oh?\"</p> <p>A: ...but I still wanted the programmer to be able to use \"defaults\" if they were okay with it.  So I settled on a compromise.</p> <p>Q: \"What was that?\"</p> <p>A: I defined <code>argparse_configure(parser)</code> in a sensible way on the infrastructure, but I didn't bind that functionality to the execution graph, or to any given interface.  If the programmer wants to do that, the program can absolutely do that, via <code>INTERFACES: {ARGPARSE_CONFIGURE: &lt;some_infrastructure_module&gt;}</code>.  Or the programmer can just manually call (for example:) <code>&lt;some_infrastructure_module&gt;.argparse_configure(parser)</code> from their own ARGPARSE_CONFIGURE implementation, and get the benefit of the parser registration.  You'll see that in the next example, by the way.</p> <p>Q: \"OK.  So, you can do automatic <code>parser.add_argument</code> registrations, but you made it just slightly less automatic, because you think most programmer's will want to tightly control how the <code>ArgumentParser</code> is configured.\"</p> <p>A: Yeah basically that's it.</p> <p>Q: \"I notice that, because only one interface can implement ARGPARSE_CONFIGURE, that ...\"</p> <p>A: Yeah, only one would be able to do it.</p> <p>Q: \"Isn't that a problem?\"</p> <p>A: Yes?  And I do think about integrating pluggy into chassis2025, or chassis2026 -- whenever the next version of chassis might be.  But in another way, I think it's saving our hides.</p> <p>Q: What do you mean?</p> <p>A: Well, it depends on Kahn's algorithm.  With a different or rejiggered execution of the scheduler, it might run the argument parsing configuration in a different order.  If the only thing is, \"Run this before parsing the arguments,\" and you had two pieces of infrastructure both wanting to add their parameters to the argument parser, then sometimes you might run it and get the presentation in one order, and other times get the presentation in another order...  Since it's user-facing, I prefer to keep it explicit.  And keeping it explicit means: Just use one single implementation of the ARGPARSE_CONFIGURE interface, and then explicitly lay down the order in which the arguments are added.  Call into the packages manually, and say, \"Add your arguments, now!\", in a specific order.</p> <p>Q: If you are going to do everything explicitly, then why did you even set up this system like chassis2024, which is about flexibility?</p> <p>A: I wanted both.  I wanted to be able to say, \"Here are a bunch of pieces of infrastructure, work out how to make them cooperate, time-wise,\" but I also wanted to be able to clarify, \"Here's the order that you should do THESE THINGS in.\"  I just want to be able to rapidly compose software from parts.  But I also recognize that the steps and promises involved in putting a running system together, and then decomposing the same system, are critically important to the design and success of that system.  And by the way, you CAN fully automate the assembly of arguments in an argument parser, in this system: just build an infrastructure package, have it look through sys.modules at the right time, find infrastructure and find implementations of a particular function, and call it.  It'll work.  I just happen to think that the ArgumentParser is user-facing and thus needs to be treated more delicately.</p>"},{"location":"ex_30_echo2/","title":"Ex #3: Echo 2","text":""},{"location":"ex_30_echo2/#an-example-echo-with-persistence","title":"An Example: Echo (with Persistence)","text":"<p>This time, we're adding data persistence to the program.</p> <p>Here, you can begin to see the power of the chassis2024 system, start to show up.</p> <p>This example builds atop the first echo.py example, which itself builds atop the helloworld.py example, ...  Read those first, before attempting this example.</p> <pre><code>import sys\n\nimport chassis2024\nimport chassis2024.basicrun\nimport chassis2024.argparse\nimport chassis2024.basicjsonpersistence\nfrom chassis2024.words import *\nfrom chassis2024.argparse.words import *\nfrom chassis2024.basicjsonpersistence.words import *\n\n\nthis_module = sys.modules[__name__]\n\n\nCHASSIS2024_SPEC = {\n    INTERFACES: {RUN: this_module,\n                 ARGPARSE_CONFIGURE: this_module}\n}\n\nEXECUTION_SPEC = {\n    BASICJSONPERSISTENCE: {\n        SAVE_AT_EXIT: True,\n        CREATE_FOLDER: False,\n        FILEPATH: \"./echo_persistence_data.json\"\n    }\n}\n\n\n# interface: ARGPARSE_CONFIGURE\ndef argparse_configure(parser):\n    parser.add_argument(\"-e\", \"--echo\",\n                        help=\"input string to echo\",\n                        default=None)\n    parser.add_argument(\"-r\", \"--repeat-last\",\n                        dest=\"repeat\",\n                        help=\"repeat the last used echo string\",\n                        action=\"store_true\")\n    chassis2024.basicjsonpersistence.argparse_configure(parser)\n\n# interface: RUN\ndef run():\n    argparser = chassis2024.interface(ARGPARSE, required=True)\n    D = chassis2024.interface(PERSISTENCE_DATA, required=True).data()\n    if argparser.args.echo is not None:\n        print(argparser.args.echo)\n        D[\"msg\"] = argparser.args.echo  # saved automatically\n    else:\n        print(D.get(\"msg\", \"use -e to specify string to echo\"))\n\n\nif __name__ == \"__main__\":\n    chassis2024.run(EXECUTION_SPEC)\n</code></pre>"},{"location":"ex_30_echo2/#noticing","title":"Noticing","text":"<p>What's new here?</p> <ul> <li><code>import chassis2024.basicjsonpersistence</code>  -- More infrastructure: the <code>chassis2024.basicjsonpersistence</code> infrastructure.</li> <li><code>EXECUTION_SPEC</code>  -- it's defined just after the EXECUTION_SPEC, and then passed as an argument to <code>chassis2024.run</code>.</li> <li><code>chassis2024.basicjsonpersistence.argparse_configure(parser)</code>  -- a call within <code>argparse_configure(parser)</code>.</li> <li><code>D = chassis2024.interface(PERSISTENCE_DATA, required=True).data()</code>  -- in the <code>run()</code> routine, persistence data is accessed via interface.</li> </ul>"},{"location":"infra_argparse/","title":"Infrastructure Documentation: argparse","text":"<p>\"Argument Parser\" instantiates an argparse.ArgumentParser, and makes it available for argument parsing.</p> <p>Other execution nodes can configure the argument parser, once it has been created, and before arguments are parsed.</p> title: Argument Parser import: <code>import chassis2024.argparse</code> words import: <code>from chassis2024.argparse.words import *</code> creates execution nodes: <code>CLEAR_ARGPARSE</code>, <code>RESET_ARGPARSE</code> implements execution nodes: <code>CLEAR_ARGPARSE</code>, <code>RESET_ARGPARSE</code>, <code>ARGPARSE</code> calls interfaces: <code>ARGPARSE_CONFIGURE</code> implements interfaces: <code>ARGPARSE</code>"},{"location":"infra_argparse/#execution-nodes","title":"Execution Nodes","text":"<pre><code>graph TD\n  clr[\"CLEAR\"];\n  clr_arg[[\"CLEAR_ARGPARSE\"]];\n  reset[\"RESET\"];\n  reset_arg[[\"RESET_ARGPARSE\"]];\n  argparse[\"ARGPARSE\"];\n  clr --&gt; reset --&gt; argparse;\n  clr --&gt; clr_arg --&gt; reset --&gt; reset_arg --&gt; argparse;\n  style clr_arg stroke:#fff,stroke-width:2px;\n  style reset_arg stroke:#fff,stroke-width:2px;\n  style argparse stroke:#fff,stroke-width:2px;</code></pre> <ul> <li>CLEAR_ARGPARSE -- nulls <code>.parsers</code>, <code>.args</code></li> <li>RESET_ARGPARSE -- sets <code>.parser</code> to argparse.ArgumentParser instance, and calls <code>.argparse_configure(parser)</code> on the ARGPARSE_CONFIGURE interface</li> <li>ARGPARSE -- <code>parser.parse_args()`` is called, and the result stored in</code>.args```.</li> </ul> <p>If you want to configure the argument parser, there are two ways to do it --</p> <ol> <li>Implement the ARGPARSE_CONFIGURE interface, which is called in the RESET_ARGPARSE execution node.</li> <li>Configure the argument parser during an execution node between RESET_ARGPARSE and ARGPARSE.</li> </ol>"},{"location":"infra_argparse/#interfaces","title":"Interfaces","text":""},{"location":"infra_argparse/#argparse","title":"ARGPARSE","text":"<p>To access the argument parser or parsed arguments, you can access the module via the ARGPARSE interface.</p> <p>It implements two data items:</p> <ul> <li><code>.parser</code> -- this is the <code>argparse.ArgumentParser</code> instance, once the RESET_ARGPARSE execution node is complete, and can be meaningfully configured up until the ARGPARSE execution node runs</li> <li><code>.args</code> -- this is the arguments parsed out from the <code>argparse.ArgumentParser</code>, once the ARGPARSE execution node is complete</li> </ul>"},{"location":"infra_argparse/#argparse_configure","title":"ARGPARSE_CONFIGURE","text":"<p>When the <code>argparse.ArgumentParser</code> is first instantiated, a call is immediately made to <code>.argparse_configure(parser)</code> on the ARGPARSE_CONFIGURE interface.</p>"},{"location":"infra_argparse/#example-use","title":"Example Use","text":"<pre><code>import sys\n\nimport chassis2024\nimport chassis2024.basicrun\nimport chassis2024.argparse\nfrom chassis2024.words import *\nfrom chassis2024.argparse.words import *\n\n\nthis_module = sys.modules[__name__]\n\n\nCHASSIS2024_SPEC = {\n    INTERFACES: {RUN: this_module,\n                 ARGPARSE_CONFIGURE: this_module}\n}\n\n\n# interface: ARGPARSE_CONFIGURE\ndef argparse_configure(parser):\n    parser.add_argument(\"-e\", \"--echo\",\n                        help=\"input string to echo\",\n                        default=\"use -e to specify string to echo\")\n\n# interface: RUN\ndef run():\n    argparser = chassis2024.interface(ARGPARSE, required=True)\n    print(argparser.args.echo)\n\n\nif __name__ == \"__main__\":\n    chassis2024.run()\n</code></pre> <p>Read the \"Echo\" tutorial for a detailed examination of this example.</p>"},{"location":"infra_basicjsonpersistence/","title":"Infrastructure Documentation: basicjsonpersistence","text":"<p>\"Basic JSON Persistence\" reads from a JSON file when your program begins, and saves the data back out when the program ends.</p> title: Basic JSON Persistence import: <code>import chassis2024.basicjsonpersistence</code> words import: <code>from chassis2024.basicjsonpersistence.words import *</code> creates execution nodes: <code>CLEAR_BASICJSONPERSISTENCE</code>, <code>RESET_BASICJSONPERSISTENCE</code>, <code>READ_BASICJSONPERSISTENCE</code>, <code>READ_PERSISTENCE</code> implements execution nodes: <code>CLEAR_BASICJSONPERSISTENCE</code>, <code>RESET_BASICJSONPERSISTENCE</code> calls interfaces: (None) implements interfaces: <code>PERSISTENCE_DATA</code>"},{"location":"infra_basicjsonpersistence/#configuration","title":"Configuration","text":""},{"location":"infra_basicjsonpersistence/#configuration-via-execution_spec","title":"Configuration via EXECUTION_SPEC","text":"<pre><code>...\nimport chassis2024.basicjsonpersistence\nfrom chassis2024.basicjsonpersistence.words import *\n...\n\nEXECUTION_SPEC = {\n    BASICJSONPERSISTENCE: {\n        SAVE_AT_EXIT: True,\n        CREATE_FOLDER: True,\n        FILEPATH: \"./data/echo_persistence_data.json\"\n    }\n}\n</code></pre> key logical type semantic type default description <code>SAVE_AT_EXIT</code> bool - True whether to save the JSON file automatically on termination, or not <code>CREATE_FOLDER</code> bool - False whether to create folders in the filepath, if they did not already exist <code>FILEPATH</code> str relative or absolute filepath \"./persistent_data.json\" path to the JSON persistence file"},{"location":"infra_basicjsonpersistence/#integration-of-argparse-with-basic-json-persistence","title":"Integration of ARGPARSE with Basic JSON Persistence","text":"<p>The design philosophy behind my implementation ensures that the argparse module does not get influenced automatically by external factors. This approach is intended to grant the program comprehensive control over how command-line options are presented and managed.</p> <p>Nonetheless, in practical scenarios, it's foreseeable that users utilizing the basicjsonpersistence module might frequently require the functionality to specify a file path for JSON persistence. To cater to this need, the module includes a specialized support function:</p> <pre><code>argparse_configure(parser, shortcutkey=\"-f\", longkey=\"--persistence-filepath\")\n</code></pre> <p>This function is designed to seamlessly align with the ARGPARSE_CONFIGURE interface. It allows for straightforward integration; you can directly assign the ARGPARSE_CONFIGURE interface to reference the basicjsonpersistence module's function if this is the sole argument parsing extension you are utilizing.</p> <p>In more complex applications, where you have multiple argument parsing requirements, it is advisable to implement your own version of the ARGPARSE_CONFIGURE interface. Within this custom implementation, you can then explicitly invoke <code>chassis2024.basicjsonpersistence.argparse_configure(parser)</code> to integrate the JSON file path configuration capability into your argument parsing logic.</p> <p>This method offers a modular and flexible approach, enabling the incorporation of JSON persistence configuration into a broader argument parsing strategy, tailored to the specific needs of your application.</p>"},{"location":"infra_basicjsonpersistence/#execution-nodes","title":"Execution Nodes","text":"<pre><code>graph TD\n  clr[\"CLEAR\"];\n  clr_me[[\"CLEAR_BASICJSONPERSISTENCE\"]];\n  reset[\"RESET\"];\n  reset_me[[\"RESET_BASICJSONPERSISTENCE\"]];\n  argparse[\"ARGPARSE\"];\n  read_me[[\"READ_BASICJSONPERSISTENCE\"]];\n  read_persistence[[\"READ_PERSISTENCE\"]];\n  activate[\"ACTIVATE\"];\n  clr --&gt; reset --&gt; argparse --&gt; activate;\n  clr --&gt; clr_me --&gt; reset --&gt; reset_me --&gt; argparse --&gt; read_me --&gt; read_persistence --&gt; activate;\n  style clr_me stroke:#fff,stroke-width:2px;\n  style reset_me stroke:#fff,stroke-width:2px;\n  style read_me stroke:#fff,stroke-width:2px;</code></pre> execution node what is done CLEAR_BASICJSONPERSISTENCE nulls <code>.parsers</code>, <code>.args</code> RESET_BASICJSONPERSISTENCE nulls <code>.parsers</code>, <code>.args</code> (redundant) READ_BASICJSONPERSISTENCE reads the file"},{"location":"infra_basicjsonpersistence/#interfaces","title":"Interfaces","text":""},{"location":"infra_basicjsonpersistence/#persistence_data","title":"PERSISTENCE_DATA","text":"<p>The PERSISTENCE_DATA interface is intended for accessing loaded data, and for manually issuing <code>save()</code> instructions before the program exits.</p> function what it does .data() returns the dictionary (which you are invited to modify) of loaded persistence data .save() forces an immediate save of the persistence data .save_at_exit(False) turns off exit-time persistence data saving .save_at_exit(True) turns back on exit-time persistence data saving .save_at_exit() returns whether exit-time persistence data saving is active or not (default is [True])"},{"location":"infra_basicjsonpersistence/#example-use","title":"Example Use","text":"<pre><code>import sys\n\nimport chassis2024\nimport chassis2024.basicrun\nimport chassis2024.argparse\nimport chassis2024.basicjsonpersistence\nfrom chassis2024.words import *\nfrom chassis2024.argparse.words import *\nfrom chassis2024.basicjsonpersistence.words import *\n\n\nthis_module = sys.modules[__name__]\n\n\nCHASSIS2024_SPEC = {\n    INTERFACES: {RUN: this_module,\n                 ARGPARSE_CONFIGURE: this_module}\n}\n\nEXECUTION_SPEC = {\n    BASICJSONPERSISTENCE: {\n        SAVE_AT_EXIT: True,\n        CREATE_FOLDER: False,\n        FILEPATH: \"./echo_persistence_data.json\"\n    }\n}\n\n\n# interface: ARGPARSE_CONFIGURE\ndef argparse_configure(parser):\n    parser.add_argument(\"-e\", \"--echo\",\n                        help=\"input string to echo\",\n                        default=None)\n    parser.add_argument(\"-r\", \"--repeat-last\",\n                        dest=\"repeat\",\n                        help=\"repeat the last used echo string\",\n                        action=\"store_true\")\n    chassis2024.basicjsonpersistence.argparse_configure(parser)\n\n# interface: RUN\ndef run():\n    argparser = chassis2024.interface(ARGPARSE, required=True)\n    D = chassis2024.interface(PERSISTENCE_DATA, required=True).data()\n    if argparser.args.echo is not None:\n        print(argparser.args.echo)\n        D[\"msg\"] = argparser.args.echo  # saved automatically\n    else:\n        print(D.get(\"msg\", \"use -e to specify string to echo\"))\n\n\nif __name__ == \"__main__\":\n    chassis2024.run(EXECUTION_SPEC)\n</code></pre> <p>Read the \"Echo (with persistence)\" tutorial for a detailed examination of this example.</p>"},{"location":"infra_basicrun/","title":"Infrastructure Documentation: basicrun","text":"<p>\"Basic Run\" is a simple one-shut execution runner.</p> <p>After everything is setup, the program calls interface <code>run()</code> on interface \"RUN\".</p> title: Basic Run module: <code>chassis2024.basicrun</code> creates execution nodes: (None) implements execution nodes: <code>UP</code> calls interfaces: <code>RUN</code> implements interfaces: (None) words import (None)"},{"location":"infra_basicrun/#execution-nodes","title":"Execution Nodes","text":"<p>When <code>UP</code> is reached (after all setup is complete,) <code>basicrun</code> calls function <code>run()</code> on the module that implements the <code>RUN</code> interface.</p>"},{"location":"infra_basicrun/#interfaces","title":"Interfaces","text":""},{"location":"infra_basicrun/#run","title":"RUN","text":"<p>The RUN interface implements a single function: <code>run()</code>, taking no parameters, and returning nothing.</p>"},{"location":"infra_basicrun/#example-use","title":"Example Use","text":"<pre><code># helloworld.py\n\nimport sys\n\nimport chassis2024\nimport chassis2024.basicrun\n\n\nCHASSIS2024_SPEC = {\n    \"INTERFACES\": {\"RUN\": sys.modules[__name__]}\n}\n\n\n# interface: RUN\ndef run():\n    print(\"Hello, world!\")\n\n\nif __name__ == \"__main__\":\n    chassis2024.run()\n</code></pre> <p>Read the \"Hello, world!\" tutorial for a detailed examination of this example.</p>"},{"location":"infra_index/","title":"Infrastructure Index","text":"<p>Chassis 2024 ships with several infrastructure packages.</p> <p>You are encouraged to write and publish your own infrastructure packages, but these are the infrastructure packages that ship by default with Chassis 2024, as of February 2024.</p> Package Module Title Description chassis2024.basicrun Basic Runner Provides a single entry point for executing your application, after all infrastructure has been loaded. chassis2024.argparse Argument Parser Instantiates an argparse.ArgumentParser, and makes it available for argument parsing. chassis2024.basicjsonpersistence Basic JSON Persistence Reads from a JSON file when your program begins, and saves the data back out when the program ends."},{"location":"intro/","title":"Introduction","text":"<p>\u300cChassis 2024\u300d\u3078\u3088\u3046\u3053\u305d!</p> <p>Have you ever found yourself juggling various bits of software infrastructure, wishing there was an easier way to piece them together? That's exactly why I created Chassis 2024.</p> <p>Think about the usual tasks you handle when writing a program -- loading configuration files, ensuring your app runs only one instance at a time with lock files, or setting up (and later tearing down) the GUI system. Or perhaps you're starting to accept TCP services. And maybe these functionalities can be configured from CLI arguments, so you've got to set up argument parsing, too. It's a lot, right? Chassis 2024 is here to make these tasks feel like a breeze.</p> <p>My goal was simple: to make reusing and combining these essential components as straightforward as possible. The cool part? With Chassis 2024, you don't have to worry about the sequence in which all these tasks happen. Thanks to some clever use of Kahn's algorithm for topological sorting, Chassis 2024 figures out the right order for you, ensuring everything runs smoothly and just as it should.</p> <p>So, if you're looking to streamline your development process and make handling infrastructure feel like a walk in the park \u2013 if you want to jump past the boring parts and get straight to 'the good part,' give Chassis 2024 a try. It's all about making your life easier, one automated step at a time.</p> <p>\u3088\u308d\u3057\u304f\u304a\u9858\u3044\u3057\u307e\u3059\u3002</p>"},{"location":"intro/#q-what-can-i-do-with-chassis-2024","title":"Q: \"What can I do with Chassis 2024?\"","text":"<p>I'm just getting started with this, so there's not much here yet, but as I program, I will be collecting more and more pieces of infrastructure.</p> <p>Here are things that you can do, today, with Chassis 2024:</p> <ul> <li>With argparse, you can automatically create and configure an argparse argument parser.</li> <li>With basicjsonpersistence, you can automatically open a JSON file, when your program begins, and then automatically save it when the program ends.</li> </ul>"},{"location":"intro/#q-how-do-i-learn-to-use-chassis-2024","title":"Q: \"How do I learn to use Chassis 2024?\"","text":"<p>There are two primary ways of using Chassis 2024:  (1) Making use of infrastructure, and (2) creating new infrastructure.  Knowing about the first comes first.  You might never want to create new infrastructure.  But if you want to, then you can learn that after learning the first.</p> <p>I've provided a set of tutorials here.  They are intended to be followed sequentially.</p> <p>Tutorial Set 1: (Making Use of Infrastructure)</p> <ul> <li>The Basics: \"Hello, World!\"</li> <li>Accessing Interfaces: Echo</li> <li>Configuring Execution: Echo w/ Persistence</li> </ul> <p>Tutorial Set 2: (Creating Infrastructure)</p> <ul> <li>...</li> </ul> <p>I haven't all of them yet, but I intend to write reference documentation over the course of March and April 2024, as well.</p> <ul> <li>Infrastructure Documentation -- documents infrastructure that ships with the <code>chassis2024</code> package</li> <li>Execution Nodes -- documents the system of execution nodes and the default execution graph</li> </ul>"},{"location":"ref_executionnode/","title":"Execution Nodes","text":"<p>Chassis 2024 is a Python framework designed to simplify the reuse of infrastructure components.  At the heart of Chassis 2024 lies the concept of execution nodes arranged into an execution graph.  These elements are fundamental to understanding how Chassis 2024 orchestrates the flow of operations within its framework, ensuring that every component interacts seamlessly and effectively.</p> <p>This document aims to explain the concepts of execution nodes and the execution graph. Whether you are integrating new infrastructure, developing modules, or simply seeking to understand the inner workings of Chassis 2024, this guide will serve as your roadmap to understanding the role of execution nodes and the execution graph in the system.</p> <p>Here's what the document covers:</p> <ul> <li> <p>Execution Nodes as Stages in Software Lifecycle: This section delves into what execution nodes are and their significance in Chassis 2024.</p> </li> <li> <p>Conceptual Use of Execution Nodes: Focuses on the practical applications of execution nodes. It explores their potential uses in a conceptual manner, without delving into the specific coding details.</p> </li> <li> <p>Technical Use of Execution Nodes: This part gets into the nitty-gritty, detailing how execution nodes and the execution graph are utilized in code.</p> </li> <li> <p>Default Execution Graph: An overview of the standard execution graph provided with Chassis 2024.</p> </li> <li> <p>Teardown: Although the execution graph primarily facilitates reaching a running state, this section discusses the process of teardown, highlighting how decommissioning is scheduled.</p> </li> </ul>"},{"location":"ref_executionnode/#execution-nodes-as-stages-in-software-lifecycle","title":"Execution Nodes as Stages in Software Lifecycle","text":"<p>In Chassis 2024, the execution graph is a dynamic and extensible framework, essential for orchestrating the flow of your application. It's designed to be effortlessly augmented by infrastructure modules, allowing developers to specify execution constraints like 'run after the \"clearing\" node' and 'run before the \"argument parsing\" node'. This extensibility is key; it means the execution graph can adapt and grow as new functionalities are integrated, without burdening the developer with the complexity of managing dependencies. Each addition is seamlessly woven into the existing structure, provided it doesn't create a cycle, which Chassis 2024 automatically checks for.</p>"},{"location":"ref_executionnode/#a-concrete-example-integrating-infrastructure","title":"A Concrete Example: Integrating Infrastructure","text":"<p>Consider a scenario in Chassis 2024 where your program has two fundamental infrastructure requirements:</p> <ol> <li>Parsing Command Line Arguments</li> <li>Reading from a Persistence File</li> </ol> <p>Suppose you want to enable specifying the persistence file's location via command line.  The necessary sequence of operations is:</p> <ol> <li>Initialize an <code>argparse.ArgumentParser</code>.</li> <li>Add a command line option to the parser for specifying the persistence file.</li> <li>Process the command line arguments using the parser.</li> <li>Access the persistence file.</li> </ol> <p>In Chassis 2024, this workflow is organized within the execution graph:</p> <ol> <li>The argument parsing infrastructure introduces a node \"CLEAR_ARGPARSE,\" which initializes a new <code>argparse.ArgumentParser</code>.  This node is configured to execute after \"RESET\" but before \"ARGPARSE\".</li> <li>The persistence file infrastructure adds a node, \"READ_PERSISTENCE\", responsible for accessing the persistence file.  This node is set to follow \"ARGPARSE\" and precede \"ACTIVATE.\"</li> </ol> <p>(Note: The default built-in nodes, titled CLEAR, RESET, ARGPARSE, CONNECT, ACTIVATE, and UP, are detailed later in this document.)</p> <p>In this manner, Chassis 2024 faciliates the easy expansion of the execution graph with new nodes like \"CLEAR_ARGPARSE\" and \"READ_CONFIG\", enhancing functionality while maintaining a straightforward and manageable workflow.</p>"},{"location":"ref_executionnode/#conceptual-use-of-exection-nodes","title":"Conceptual Use of Exection Nodes","text":""},{"location":"ref_executionnode/#association-of-execution-nodes-with-packages","title":"Association of Execution Nodes with Packages","text":"<p>In Chassis 2024, each execution node is typically associated with a specific package. When the system reaches an execution node, if it's associated with a package, that package's perform_execution_graph_node function is invoked with the execution node's name. This function performs the actions defined for that stage of the application's lifecycle.</p>"},{"location":"ref_executionnode/#declaration-of-execution-node-sequences-by-packages","title":"Declaration of Execution Node Sequences by Packages","text":"<p>Packages in Chassis 2024 declare their own sequences of execution nodes. This declaration includes specifying which nodes they will respond to and perform actions for. This mechanism allows packages to integrate their specific functionalities into the broader application flow.</p>"},{"location":"ref_executionnode/#single-package-association-per-execution-node","title":"Single Package Association per Execution Node","text":"<p>To maintain clarity and order within the system, each execution node can only be associated with one package. If multiple packages attempt to associate with the same execution node, Chassis 2024 raises a MultiplePackagesHandlingExecutionGraphNode exception. This rule ensures a clear and unambiguous order of operations.</p>"},{"location":"ref_executionnode/#execution-graph-assembly-and-execution-by-chassis-2024","title":"Execution Graph Assembly and Execution by Chassis 2024","text":"<p>Chassis 2024 automatically assembles the execution graph based on the data collected from all packages, including their execution nodes and sequences. It then performs a topological sort of the graph to determine the execution order, ensuring that all dependencies and prerequisites are met.</p>"},{"location":"ref_executionnode/#technical-use-of-execution-nodes","title":"Technical Use of Execution Nodes","text":""},{"location":"ref_executionnode/#definition-of-chassis2024_spec-by-packages","title":"Definition of CHASSIS2024_SPEC by Packages","text":"<p>Infrastructure packages in Chassis 2024 define a variable CHASSIS2024_SPEC, which declare the packages participation within the Chassis 2024 system.  This declaration includes keys like EXECUTES_GRAPH_NODES and EXECUTION_GRAPH_SEQUENCES, determining the execution nodes the package responds to and the sequences it adds to the overall execution graph.</p> <p>Consider the following example from the basicjsonpersistence package definition:</p> <pre><code>CHASSIS2024_SPEC = {\n    # Nodes this package will execute\n    EXECUTES_GRAPH_NODES: [CLEAR_BASICJSONPERSISTENCE,\n                           RESET_BASICJSONPERSISTENCE,\n                           READ_BASICJSONPERSISTENCE],\n    # Sequences of nodes in the execution graph\n    EXECUTION_GRAPH_SEQUENCES: [(CLEAR,\n                                 CLEAR_BASICJSONPERSISTENCE,  # Node triggered by CLEAR\n                                 RESET,\n                                 RESET_BASICJSONPERSISTENCE,  # Node triggered by RESET\n                                 ARGPARSE,\n                                 READ_BASICJSONPERSISTENCE,  # Node triggered by ARGPARSE\n                                 READ_PERSISTENCE,  # Signal completion of persistence load\n                                 ACTIVATE)],\n    ...\n}\n</code></pre> <p>The EXECUTES_GRAPH_NODES key associates the package with the specific nodes: CLEAR_BASICJSONPERSISTENCE, RESET_BASICJSONPERSISTENCE, and READ_BASICJSONPERSISTENCE.  This list defines the nodes that this package is responsible for within the execution graph.</p> <p>In the EXECUTION_GRAPH_SEQUENCES sub-key, the specified sequence (<code>CLEAR</code>, <code>CLEAR_BASICJSONPERSISTENCE</code>, <code>RESET</code>, etc.) outlines the order in which nodes should be activated. This sequence ensures a structured flow of execution. The tuple within the list allows for the definition of multiple sequences, providing flexibility and accommodating complex execution flows.</p> <p>In summary, defining CHASSIS2024_SPEC ensures that infrastructure components in Chassis 2024 execute their instructions at the correct times.</p>"},{"location":"ref_executionnode/#execution-of-nodes-by-packages","title":"Execution of Nodes by Packages","text":"<p>One might wonder, \"How exactly is an execution node activated within Chassis 2024?\" The answer lies in the well-defined interaction between execution nodes and the packages responsible for them.</p>"},{"location":"ref_executionnode/#role-of-the-perform_execution_graph_node-function","title":"Role of the perform_execution_graph_node Function","text":"<p>Each infrastructure package defines a critical function: <code>perform_execution_graph_node(execution_graph_node)</code>. This function is the heart of the node execution process.</p> <ul> <li> <p>Function Responsibility: This function is responsible for executing the actions assigned to a specific execution nodes. When an execution node is reached in the graph, Chassis 2024 calls this function from the associated package.</p> </li> <li> <p>Node-Specific Logic: Inside this function, there is logic to handle different nodes. This is typically implemented using conditional statements, which check the name of the execution node passed as an argument and execute the corresponding actions.</p> </li> </ul> <p>For instance, consider the following snippet from the basicjsonpersistence package:</p> <pre><code>def perform_execution_graph_node(n):\n    ...\n    if n == CLEAR_BASICJSONPERSISTENCE:\n        # Actions for clearing basic JSON persistence (x1 execution)\n        ...\n\n    elif n == RESET_BASICJSONPERSISTENCE:\n        # Actions for resetting basic JSON persistence\n        ...\n\n    elif n == READ_BASICJSONPERSISTENCE:\n        # Actions for reading basic JSON persistence\n        ...\n</code></pre> <p>In this example, the function perform_execution_graph_node contains specific actions for each of the execution nodes like CLEAR_BASICJSONPERSISTENCE, RESET_BASICJSONPERSISTENCE, and READ_BASICJSONPERSISTENCE.</p>"},{"location":"ref_executionnode/#package-node-association","title":"Package-Node Association","text":"<ul> <li> <p>Tracking Responsibility: Chassis 2024 maintains a mapping of which package responds to each execution node. This is crucial for orchestrating the execution flow.</p> </li> <li> <p>Execution Mechanics: When the execution graph reaches a particular node, Chassis 2024 looks up the package associated with that node. It then locates the <code>perform_execution_graph_node</code> function within that package and invokes it, passing the name of the execution node as an argument.</p> </li> </ul> <p>This systematic approach ensures that each execution node is handled by its respective package in a structured and orderly fashion, contributing to the streamlined operation of the overall system.</p>"},{"location":"ref_executionnode/#default-execution-graph","title":"Default Execution Graph","text":"<p>Chassis 2024 comes with a predefined execution graph, which forms the backbone of its operational structure. This graph comprises several key nodes: CLEAR, RESET, ARGPARSE, CONNECT, ACTIVATE, and UP. Each node serves a specific purpose in the lifecycle of an application, ensuring a structured and efficient process flow. Below is a detailed description of each default node in the execution graph:</p> <pre><code>graph TD\n  clr[\"CLEAR\"];\n  reset[\"RESET\"];\n  argparse[\"ARGPARSE\"];\n  connect[\"CONNECT\"];\n  activate[\"ACTIVATE\"];\n  up[\"UP\"];\n  clr --&gt; reset --&gt; argparse --&gt; connect --&gt; activate --&gt; up;</code></pre>"},{"location":"ref_executionnode/#clear","title":"CLEAR","text":"<p>The CLEAR node is the initial stage of the execution graph. It's designed for one-time setup tasks that are essential at the beginning of an application's lifecycle. Activities in this node include initializing internal data structures and pre-generating values that will remain constant throughout the operation of the application, such as pre-calculated trigonometric tables. This setup ensures that subsequent nodes operate on a well-prepared and stable groundwork.</p>"},{"location":"ref_executionnode/#reset","title":"RESET","text":"<p>Following CLEAR is the RESET node. While CLEAR is for one-time initializations, RESET focuses on setups that might need to be repeated, particularly in testing scenarios. This node allows for the reinitialization of variables and states that may need resetting multiple times during an application's testing lifecycle. RESET is crucial for ensuring the application can return to a known state, which is especially important for iterative development and testing processes.</p>"},{"location":"ref_executionnode/#argparse","title":"ARGPARSE","text":"<p>The ARGPARSE node is dedicated to processing command line arguments. In this stage, the application parses any input parameters it requires before proceeding further. This ensures that all necessary inputs are correctly interpreted and available for use by the application, enabling it to adapt its behavior based on user inputs or configuration directives provided at launch.</p>"},{"location":"ref_executionnode/#connect","title":"CONNECT","text":"<p>At the CONNECT node, the application establishes connections to necessary external resources. This could involve a wide range of activities, such as loading configuration files, reading necessary data from files, or establishing network connections with external systems and services. The CONNECT node is critical for integrating the application with the outside world and for accessing resources that are essential for its operation.</p>"},{"location":"ref_executionnode/#activate","title":"ACTIVATE","text":"<p>Once all the necessary resources are connected, the ACTIVATE node takes over. This node is responsible for setting up the internal state of the application, which may involve cross-referencing and integrating data from multiple sources. It's also the stage where user interfaces are typically initialized, including graphical user interfaces (GUIs) or other interaction elements. ACTIVATE essentially prepares the application to start its main functionality.</p>"},{"location":"ref_executionnode/#up","title":"UP","text":"<p>Finally, the UP node represents the application's active running state. Here, the core functionalities of the program are executed. This is where the application performs its intended tasks, whether it's processing data, responding to user inputs, or any other primary operations for which the application was designed. The UP node is where the application delivers its value to the user.</p>"},{"location":"ref_executionnode/#teardown","title":"Teardown","text":"<p>Teardown is a crucial phase in the lifecycle of an application using Chassis 2024. It handles the orderly and safe shutdown or cleanup of processes that have been initiated by various execution nodes. This phase becomes especially important in maintaining the integrity and consistency of the application, particularly in scenarios where an abrupt termination or an unexpected exception occurs.</p>"},{"location":"ref_executionnode/#mechanism-of-teardown","title":"Mechanism of Teardown","text":"<p>During the execution of nodes, it's common for certain setup or initialization actions to require corresponding cleanup actions. To manage this, Chassis 2024 provides a mechanism where nodes can register teardown callbacks through the <code>chassis.call_before_termination(callback)</code> function.</p>"},{"location":"ref_executionnode/#callback-registration","title":"Callback Registration","text":"<ul> <li>Function Usage: Execution nodes can call <code>chassis.call_before_termination(callback)</code> to register a callback function for teardown activities.</li> <li>Callback Function: The callback function provided should take no arguments, and its return value is ignored.</li> </ul> <p>Here's an example snippet from the basicjsonpersistence package:</p> <pre><code>def perform_execution_graph_node(n):\n    ...\n    if n == CLEAR_BASICJSONPERSISTENCE:\n        ...\n\n    elif n == RESET_BASICJSONPERSISTENCE:\n        ...\n\n    elif n == READ_BASICJSONPERSISTENCE:\n        # Make sure that while closing down, that the data is saved.\n        chassis2024.chassis.call_before_termination(_do_final_save)\n        ...\n\ndef _do_final_save():\n    ...\n</code></pre>"},{"location":"ref_executionnode/#execution-order-of-callbacks","title":"Execution Order of Callbacks","text":"<ul> <li>Reverse Order Execution: These callbacks are executed in the reverse order of their registration. This reverse order ensures that the teardown process mirrors the setup process, maintaining a logical and efficient order of operations.</li> <li>Example Scenario: If an execution node A registers a callback cb_A, and a subsequent node B registers cb_B, the teardown process will first call cb_B and then cb_A.</li> </ul>"},{"location":"ref_executionnode/#teardown-during-unhandled-exceptions","title":"Teardown During Unhandled Exceptions","text":"<ul> <li>Exception Handling: In the event of an unhandled exception occurring during the execution of nodes, Chassis 2024 ensures that the teardown process is still reliably executed.</li> <li>Callback Invocation: All registered callbacks are invoked in reverse order, just as they would be in a normal termination scenario. This ensures that even in the face of unexpected interruptions, the application can perform necessary cleanup, reducing the risk of corrupted states or resources being left in an indeterminate state.</li> </ul>"}]}